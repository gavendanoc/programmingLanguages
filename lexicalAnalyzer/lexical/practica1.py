# -*- coding: utf-8 -*-
"""practica1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K3pPh4yTvPVULAcyTA4UEWQOZzcwVvdL
    
 
Members:
* Gabriel Andres Avendaño Casadiego  gavendanoc@unal.edu.co
* Santiago Duque Bernal              saduquebe@unal.edu.co
* Juan Diego Medina Naranjo          jmedinan@unal.edu.co

"""

def preprocessLine(line):
  return line.replace("\t", " " * 4)

class Token:
  reserved_words = (
    "print",
    "input",
    "id", # Preguntar
    "when",
    "if",
    "unless",
    "while",
    "return",
    "until",
    "loop",
    "do",
    "else",
    "repeat",
    "num",
    "for",
    "end",
    "next",
    "break",
    "not",
    "and",
    "or",
    "var",
    "function",
    "true",
    "false",
    "bool", # Consideracion profe
    "return"
  )

  def __init__ (self, token, lexema, row, col):
    self.token = token
    self.lexema = lexema
    self.row = row
    self.col = col

    if self.lexema.text in self.reserved_words:
      self.token = self.lexema.text

  def __str__ (self):
    if self.token in ["id", "fid", "tk_num"]:
      return f"<{self.token},{self.lexema},{self.row},{self.col}>"
    return f"<{self.token},{self.row},{self.col}>"

class Lexema:
  def __init__(self,initialPosition = -1, text = ""):
    self.initialPosition = initialPosition
    self.text = text
  
  def add(self,ch, position):
    self.text += ch
    if self.initialPosition == -1:
      self.initialPosition = position

  def pop(self):
    self.text = self.text[:-1]
    return self.text
  
  def restart(self):
    self.text = ""
    self.initialPosition = -1

  def __str__(self):
    return self.text

# Valores tomados del esquema de Draw.io
getTokenFromState = {
    -2   : "tk_llave_izq",
    -3   : "tk_llave_der",
    -4   : "tk_par_izq",
    -5   : "tk_par_der",
    -10  : "tk_coma",
    -11  : "tk_puntoycoma", 
    -12  : "tk_mas",
    -122 : "tk_sum_asig",
    -123 : "tk_incremento",
    -13  : "tk_mayor",
    -132 : "tk_mayor_igual",
    -14  : "tk_menor",
    -142 : "tk_menor_igual",
    -15  : "tk_dospuntos",
    -152 : "tk_asignacion",
    -16  : "tk_div",
    -162 : "tk_div_asig",
    -17  : "tk_mod",
    -172 : "tk_mod_asig",
    -18  : "tk_mul",
    -182 : "tk_mul_asig",
    -19  : "tk_igualdad",
  # -192 : NO APLICA
    -201 : "tk_diferente",
    -21  : "tk_menos",
    -212 : "tk_res_asig",
    -213 : "tk_decremento",
    -221 : "tk_num",
    -301: "id",
    -311: "fid"
}

#siguiente estado desde state = 0
def nextStatefromInitial(ch, *_):
  if ch.isdigit(): return (22, 1)
  if ch.isalpha(): return (30, 1)

  characters = {
      '{': (2, 1),
      '}': (3, 1),
      '(': (4, 1),
      ')': (5, 1),
      '#': (6, 1),
      ',': (10,1),
      ';': (11,1),
      '+': (12,1),
      '>': (13,1),
      '<': (14,1),
      ':': (15,1),
      '/': (16,1),
      '%': (17,1),
      '*': (18,1),
      '=': (19,1),
      '!': (20,1),
      '-': (21,1),
      '@': (31,1),
      ' ': (100,1),
      '\n': (-101,1), # --->> Cambiado por gabriel
      # incluir todos los caracteres que son validos como primer caracter en los tokens
  }
  error = ("error",0)
  next = characters.get(ch,error)
  return next

leftCurlyBracketCharacter = lambda ch, st : (-2, 0)
rightCurlyBracketCharacter  = lambda ch, st : (-3, 0)
leftParenthesesCharacter = lambda ch, st : (-4, 0)
rightParenthesesCharacter = lambda ch, st : (-5, 0)
hashtagCharacter = lambda ch, st : (-6,0)
commaCharacter = lambda ch, st : (-10, 0)
semicolonCharacter = lambda ch, st : (-11, 0)


# posibles opciones conociendo que se esta en el estado 12 (se ha leido un '+')
def sumCharacter(ch, *_):
  characters = {
      '=': (-122,1), # SUMA ASIGNACION
      '+': (-123,1), # INCR
  }
  otherCharacter = (-12,0) #SUMA
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 13 (se ha leido un '>')
def mayorCharacter(ch, *_):
  characters = {
      '=': (-132,1), # MAYOR O IGUAL
  }
  otherCharacter = (-13,0) #MAYOR
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 14 (se ha leido un '<')
def menorCharacter(ch, *_):
  characters = {
      '=': (-142,1), # MENOR O IGUAL
  }
  otherCharacter = (-14,0) #MENOR
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 15 (se ha leido un ':')
def dospuntosCharacter(ch, *_):
  characters = {
      '=': (-152,1), # ASIGNACION
  }
  otherCharacter = (-15,0) #DOS PUNTOS
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 16 (se ha leido un '/')
def divisionCharacter(ch, *_):
  characters = {
      '=': (-162,1), #DIVISION ASIGNACION
  }
  otherCharacter = (-16,0) #DIVISION
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 17 (se ha leido un '%')
def moduloCharacter(ch, *_):
  characters = {
      '=': (-172,1), #MODULO ASIGNACION
  }
  otherCharacter = (-17,0) #MODULO
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 18 (se ha leido un '*')
def multiplicacionCharacter(ch, *_):
  characters = {
      '=': (-182,1), #MULTIPLICACION ASIGNACION
  }
  otherCharacter = (-18,0) #MULTIPLICACION
  next = characters.get(ch,otherCharacter)
  return next

# posibles opciones conociendo que se esta en el estado 19 (se ha leido un '=')
def igualCharacter(ch, *_):
  characters = {
      '=': (-19,1), # COMPRACION ==
  }
  error = ("error",-1) #ERROR: -1 porque el error esta en el character anterior
  next = characters.get(ch,error)
  return next

# posibles opciones conociendo que se esta en el estado 20 (se ha leido un '!')
def exclamationCharacter(ch, *_):
  characters = {
      '=': (-201,1), # DIFERENCIA !=
  }
  error = ("error",-1) #ERROR: -1 porque el error esta en el character anterior
  next = characters.get(ch,error)
  return next

# posibles opciones conociendo que se esta en el estado 21 (se ha leido un '-')
def subtractCharacter(ch, *_):
  characters = {
      '=': (-212,1), # RESTA ASIGNACION
      '-': (-213,1), # DECR
  }
  otherCharacter = (-21,0) # RESTA
  next = characters.get(ch,otherCharacter)
  return next

def readNumber(ch, state):
  otroCharacter = (-221, 0)
  if state == 22: # Digito antes punto -> 
    if ch.isdigit(): return (22, 1)
    if ch == '.': return (222, 1)
    return otroCharacter
  elif state == 222: # punto character -> 
    if ch.isdigit(): return (2_222, 1)
    return (-221, -1) 
  elif state == 2_222: # Digito despues del punto -> 
    if ch.isdigit(): return (2_222, 1)
    return otroCharacter
  else:
    raise Exception("State not defined for realNumber function")

def readIdentifier(ch, *_):
  if ch.isdigit() or ch.isalpha(): return (30, 1)
  otroCharacter = (-301, 0)
  return otroCharacter

def readFunction(ch, state):
  if state == 31:
    if ch.isalpha(): return (310, 1)
    otroCharacter = ("error", -1)
    return otroCharacter
  elif state == 310:
    if ch.isdigit() or ch.isalpha(): return (310, 1)
    otroCharacter = (-311, 0)
    return otroCharacter
  else:
    raise Exception("State not defined for readFunction function")

def delta (state, ch):
  nextStateFunction = {
      0: nextStatefromInitial,
      2: leftCurlyBracketCharacter,
      3: rightCurlyBracketCharacter,
      4: leftParenthesesCharacter,
      5: rightParenthesesCharacter,
      6: hashtagCharacter,
      10: commaCharacter,
      11: semicolonCharacter,
      12: sumCharacter,
      13: mayorCharacter,
      14: menorCharacter,
      15: dospuntosCharacter,
      16: divisionCharacter,
      17: moduloCharacter,
      18: multiplicacionCharacter,
      19: igualCharacter,
      20: exclamationCharacter,
      21: subtractCharacter,
      22: readNumber,
      222: readNumber,
      2_222: readNumber,
      30: readIdentifier,
      31: readFunction,
      310: readFunction,
      100: lambda ch, st: (-100,0),
      101: lambda ch, st: (-101,0),
  }
  error = lambda ch, st: ("error", 0)
  nextState = nextStateFunction.get(state,error)

  return nextState(ch, state)

class LexicalError(Exception):
  def __init__(self, row, col):
    self.message = ">>> Error léxico(línea:{},posición:{})".format(row, col)
    super().__init__(self.message)

  def __str__(self):
    return self.message

def getTokens(data=[]):
  for row in range(len(data)):
    line = preprocessLine(data[row])
    i = 0
    lexema = Lexema()
    state, move = 0, 0
    
    while (i < len(line)):
      ch = line[i]
      state, move = delta(state, ch)

      if move == 1: # El caracter pertence al lexema
        lexema.add(ch,i+1)

      if state == "error":
        raise LexicalError(row + 1, i + move + 1)
      elif state == -6: # Comentario, saltar linea
        break
      elif state == -100 or state == -101: # espacion en blanco o fin de linea
        state = 0
        lexema.restart()
      elif state < 0:
        for _ in range(-move): 
          lexema.pop()
        
        yield Token(getTokenFromState[state], lexema, row+1, lexema.initialPosition)
        state = 0
        lexema.restart()
        
      i += move


if __name__ == "__main__":
  import sys 
  data = sys.stdin.readlines() # Ctrl+d para detener lectura
  try:
    for token in getTokens(data):
      print(token)
  except LexicalError as le:
    print(le.message)
